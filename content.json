{"meta":{"title":"clock","subtitle":"","description":"","author":"John Doe","url":"https://ljweb.xyz","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-02-16T14:10:43.372Z","updated":"2022-02-16T14:10:43.372Z","comments":false,"path":"/404.html","permalink":"https://ljweb.xyz/404.html","excerpt":"","text":":love_letter:TEST:新建文章"},{"title":"关于","date":"2022-02-16T14:10:43.468Z","updated":"2022-02-16T14:10:43.468Z","comments":false,"path":"about/index.html","permalink":"https://ljweb.xyz/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-02-16T14:10:43.468Z","updated":"2022-02-16T14:10:43.468Z","comments":false,"path":"books/index.html","permalink":"https://ljweb.xyz/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-16T14:10:43.468Z","updated":"2022-02-16T14:10:43.468Z","comments":false,"path":"categories/index.html","permalink":"https://ljweb.xyz/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-16T14:10:43.472Z","updated":"2022-02-16T14:10:43.472Z","comments":true,"path":"links/index.html","permalink":"https://ljweb.xyz/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-16T14:10:43.472Z","updated":"2022-02-16T14:10:43.472Z","comments":false,"path":"repository/index.html","permalink":"https://ljweb.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-16T14:10:43.472Z","updated":"2022-02-16T14:10:43.472Z","comments":false,"path":"tags/index.html","permalink":"https://ljweb.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"51单片机的延时函数","slug":"51单片机的延时函数","date":"2022-01-10T04:20:30.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2022/01/10/51单片机的延时函数/","link":"","permalink":"https://ljweb.xyz/2022/01/10/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"参考： 51单片机的延时计算_海草海草的博客-CSDN博客_单片机delay延时时间怎么算 方法：1.使用STC-ISP软件中的软件延时计算器(只能生成固定时间的函数)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ljweb.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"https://ljweb.xyz/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"2021电赛总结","slug":"2021电赛总结","date":"2021-12-13T15:10:08.000Z","updated":"2022-02-16T14:10:43.372Z","comments":true,"path":"2021/12/13/2021电赛总结/","link":"","permalink":"https://ljweb.xyz/2021/12/13/2021%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"挫折之后的成长&emsp;&emsp;2021年的电赛过去近两个月了，这是我第一次参加电赛，虽然最后没能完赛（我太菜啦！）但是经过这次的电赛的经历也让我认识到了和大佬的差距和自身的不足。也让我彻底爱上了这种学习、设计，制作、头脑风暴的感觉。希望自己能记住这次的失利，记住这落差。不会被一时的挫折而抹杀专注和热爱，以后好好玩且玩好！ 赛题分析&emsp;&emsp;我们组选择的是F题：做一个送药小车，基础题一共有三个任务（因为是第一次参加电赛我们就奔着基础题去了），小车先要在起点识别出给定的数字（数字打印在纸上），取到药品后循迹去数字对应的药房，然后等待药品卸货，最后自主返回起点。 &emsp;&emsp;4号早上题目出来后，我和队员们一时都傻了眼！因为我们都是大二的同学，如果此次电赛不推迟到11月的话，我们队伍甚至才大一，我们谁都没有做这么难项目的经验。实不相瞒，以我们团队目前的水平只能写个51单片机，当时五月份报名参加电赛的时候也是抱着见世面去试一试的，而参加这次比赛的学长们，也都放弃了以往相对简单的但今年难度上天的小车题（当然其他组的题目也不好做），所以我们面对的情况就是，全校就两组在做小车题（另一组也是和我们一样，大二，没有相关经验）。 电赛F题的难点：1.循迹： &emsp;&emsp;我做过一个用红外来循迹的51小车，但是题目为了增大难度，如图，轨道中间的线是红色的（因为红色和赛道背景的白色反差不像黑色和白色那样大😭），所以用不了红外的方案。这下我们想到的就是使用OpenMv进行视觉循迹（其实也可以用灰度传感器！），可是我们从来没接触过OpenMv，只能现学现做，还好我从一个做无人机组的学长那里借来了一个OpenMv，这让我能题目确定之后立马开始学习OpenMv。然后老师也帮我们买了新的OpenMv模块，解决了燃眉之急。 &emsp;&emsp;在我开始学习OpenMv的时候，另外一名队友在做小车的硬件部分，因为实验室有很多四驱小车的车模，所以我们最后就采用了。 &emsp;&emsp;我们用的是Arduino uno当下位机，原因是arduino比较简单，程序很好写，我当时的想法是信息处理和电机动作控制都在OpenMv上做，arduino只用来进行简单的收到串口通讯指令后控制电机和两个LED灯。 &emsp;&emsp;红线循迹的部分我第二天实现了，也能识别出十字路口，然后停下。 2.数字识别： &emsp;&emsp;数字识别我也用的是OpenMv的模板匹配，识别效果还行，就是对小车的角度和距离都比较高，但是没办法，比赛已经到第二天了，再买元件已经来不及了，只能硬着头皮做下去。 &emsp;&emsp;数字识别在第三天的最后也做得差不多了，到这里，小车已经能从起点出发，循迹找到十字路口后，停下来进行识别了，或者进行转弯。两天内从0开始学习到能识别到数字还是很激动的，这得益于OpenMv好上手的特性，这也是我当初选择OpenMv的原因。可也带来很大弊端，因为我从来没有学过python，后面逻辑部分没有了历程的支持我就遇到大问题了。 最后还在写代码的老胡（请忽略我们很乱的实验室 😂 ） 3.逻辑&emsp;&emsp;赛题要求一套代码解决所有问题，对没什么经验的我来说，这难度比上天还难，因为我们只有OpenMv，所以只能在上面又跑循迹又跑数字识别，逻辑就很难写，虽然我们队伍里面有一位计算机的同学，他学过python，但由于我们都是第一次接触OpenMv，在最后我熬了一晚上，白天又战斗了最后十几小时之后，我们还是失败了。 总结&emsp;&emsp;其实不难发现，我们这次的失败是必然的。因为团队里面没有一个人有学过这些知识，知识储备不足是一方面。还有队员的任务分配也出现了一些问题，电赛是三人一组，我们当时的分配是一个人负责打杂和写设计报告，另外两个一个负责整个项目的制作部分。因为选择的题目对我们来说太难，除了我学习了点OpenMv之外，另外两名队员没能参与进来，导致分工不合理。 &emsp;&emsp;但我还是觉得能参加这样的比赛，很值得，比赛的过程很过瘾，特别是解决一个又一个问题的过程。这让我更加有动力去学习，补缺补差。明年的比赛我们还会参加的！ 感谢&emsp;&emsp;❤️真的很感谢比赛中学校和老师们的帮助，也很感谢好队友给我带饭，能让我选择困难的题目挑战自己。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ljweb.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OpenMv","slug":"OpenMv","permalink":"https://ljweb.xyz/tags/OpenMv/"}]},{"title":"使用51单片机驱动蜂鸣器播放音乐","slug":"使用51单片机驱动蜂鸣器播放音乐","date":"2021-11-29T15:49:50.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/29/使用51单片机驱动蜂鸣器播放音乐/","link":"","permalink":"https://ljweb.xyz/2021/11/29/%E4%BD%BF%E7%94%A851%E5%8D%95%E7%89%87%E6%9C%BA%E9%A9%B1%E5%8A%A8%E8%9C%82%E9%B8%A3%E5%99%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/","excerpt":"","text":"参考：https://blog.csdn.net/m0_37697335/article/details/84915995 有源蜂鸣器与无源蜂鸣器的区别无源蜂鸣器的特点是：1、 无源内部不带震荡源，所以如果用直流信号无法令其鸣叫。必须用2K~5K的方波（建议使用PWM）去驱动它 2、 声音频率可控，可以做出“多来米发索拉西”的效果。 3、 可以使呈现的发音效果更丰富，当然控制方式也因此变得比有源蜂鸣器更复杂一点。 有源蜂鸣器的特点是：1 、有源蜂鸣器内部带震荡源，所以只要一通电就会叫2、 程序控制方便，单片机一个高低电平就可以让其发出声音，而无源蜂鸣器却做不到。 3、 效果单一，但是控制简单，如果仅是作为单一无变化的提示音使用，有源蜂鸣器无疑是一种好选择。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;reg52.h&gt;#define RldTmr(fr) 65536 - (11059200 / 12) / (fr &lt;&lt; 1)#define FuDian(n) (n &lt;&lt; 1) / 3 //附点n分音符的换算 typedef unsigned char UCHAR;typedef unsigned int UINT;typedef unsigned long ULONG; sbit BUZZ = P0^0; UINT code noteFreq[] = &#123; //中音 1-7 和高音 1-7对应的频率列表 523, 587, 659, 698, 784, 880, 988, 1047, 1175, 1319, 1397, 1568, 1760, 1976&#125;;UINT code tmrRld[] = &#123; //中音 1-7 和高音 1-7对应的定时器重载值 RldTmr(523), RldTmr(587), RldTmr(659), RldTmr(698), RldTmr(784), RldTmr(880), RldTmr(988), RldTmr(1047), RldTmr(1175), RldTmr(1319), RldTmr(1397), RldTmr(1568), RldTmr(1760), RldTmr(1976),&#125;;UCHAR code musicNote[] = &#123; //音名 1, 2, 3, 1, 1, 2, 3, 1, 3, 4, 5, 3, 4, 5, 5, 6, 5, 4, 3, 1, 5, 6, 5, 4, 3, 1, 1, 5, 1, 1, 5, 1&#125;;UCHAR code noteDuration[] = &#123; //音名对应的时值，4表示4分音符，8表示8分音符，16表示16分音符 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 2, FuDian(8), 16, FuDian(8), 16, 4, 4, FuDian(8), 16, FuDian(8), 16, 4, 4, 4, 4, 2, 4, 4, 2&#125;;bit enable = 1, tmrFlg = 0;UCHAR T0RH = 0XFF, T0RL = 0X00; void Delay(UINT n);void PlayMusic(UCHAR speed); //固定标准为4分音符的速度：例如speed = 108 表示一分钟扫过108个4分音符 void main() &#123; EA = 1; TMOD = 0X01; TH0 = T0RH; TL0 = T0RL; ET0 = 1; TR0 = 1; while (1) &#123; PlayMusic(72); Delay(40000u); &#125;&#125; void Delay(UINT n) &#123; UINT i; for (i = 0; i &lt; n; i++) ;&#125; void PlayMusic(UCHAR speed) &#123; UCHAR i; UCHAR idx; UINT cnt = 0; UINT durationCnt = 0; //当前音符的时值对应的定时器计数 UINT soundCnt = 0; //当前音符的发声时值对应的计数值 for (i = 0; i &lt; sizeof (musicNote); ) &#123; while (!tmrFlg) ; tmrFlg = 0; if (cnt == 0) &#123; idx = musicNote[i] - 1; T0RH = tmrRld[idx] &gt;&gt; 8; T0RL = tmrRld[idx]; durationCnt = (ULONG)240 * (ULONG)noteFreq[idx] / ((ULONG)noteDuration[i] * (ULONG)speed); soundCnt = durationCnt - (durationCnt &gt;&gt; 2); //当前音符时值的前3/4发声，后1/4静音 enable = 1; cnt++; &#125; else &#123; if (cnt == durationCnt) &#123; cnt = 0; i++; &#125; else &#123; cnt++; if (cnt == soundCnt) &#123; enable = 0; &#125; &#125; &#125; &#125;&#125; void InterruptTmr0() interrupt 1 &#123; TH0 = T0RH; TL0 = T0RL; tmrFlg = 1; if (enable) BUZZ = ~BUZZ; else BUZZ = 1;&#125;","categories":[{"name":"51单片机","slug":"51单片机","permalink":"https://ljweb.xyz/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51","slug":"51","permalink":"https://ljweb.xyz/tags/51/"}]},{"title":"有限差分法处理电磁场问题","slug":"有限差分法处理电磁场问题","date":"2021-11-28T16:00:00.000Z","updated":"2022-02-16T14:10:43.468Z","comments":true,"path":"2021/11/28/有限差分法处理电磁场问题/","link":"","permalink":"https://ljweb.xyz/2021/11/28/%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86%E6%B3%95%E5%A4%84%E7%90%86%E7%94%B5%E7%A3%81%E5%9C%BA%E9%97%AE%E9%A2%98/","excerpt":"","text":":mag: 参考代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455clear allm=22;for k=1:m for j=1:m if k==1 V(j,k)=1; elseif ((j==1)|(j==m)|(k==m)) V(j,k)=0; else V(j,k)=0.5; end endendcha=0.01;delta=0;n=0;while(1) n=n+1; for k=2:m-1 for j=2:m-1 Vnew(j,k)=0.25*(V(j+1,k)+V(j-1,k)+V(j,k+1)+V(j,k-1)); d=abs((Vnew(j,k)-V(j,k))/V(j,k)); if d&gt;delta delta=d; end V(j,k)=Vnew(j,k); end end if delta&lt;cha break; end if n&gt;100 break; end delta=0.;endk=1:m;j=1:m;figure(1)[DX,DY]=gradient(V,.4,.4);hold onquiver(k,j,DX,DY,2)hold offxlabel(&#x27;电场线图像&#x27;)title(&#x27;姓名&#x27;)figure(2)[DX,DY]=gradient(V,.4,.4)A=(DX.^2+DY.^2).^0.5;[DA,DB]=gradient(A,.4,.4);hold onquiver(k,j,DA,DB,2)hold offxlabel(&#x27;电力线图像&#x27;)title(&#x27;姓名&#x27;)","categories":[],"tags":[{"name":"实验","slug":"实验","permalink":"https://ljweb.xyz/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"mini Macintosh plus(基于ESP32)","slug":"mini-macintosh-plus-基于ESP32","date":"2021-11-25T12:54:21.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/25/mini-macintosh-plus-基于ESP32/","link":"","permalink":"https://ljweb.xyz/2021/11/25/mini-macintosh-plus-%E5%9F%BA%E4%BA%8EESP32/","excerpt":"","text":"参考：Sprites mods - Miniature Macintosh Plus - Intro Intro Back in the early days of computing, there was a company called Apple. They just had great success with their Apple II line of computers, but needed to innovate to stay on top of the quickly-developing computer scene. They already were working on the Lisa line of computers, a minicomputer-inspired beast intended for business users and priced as such, but that was deemed too expensive for the average customer. As a secondary project, the Macintosh was developed, initially with the idea in mind to make a new generation of computer for ‘the man on the street’ which should cost about $500. Steve Jobs got put on the project, and under him the hardware got more advanced,the software got a GUI instead of a text interface, and the price ballooned into almost $2500. Although the hardware you got for this price was slightly underwhelming, lacking e.g. the graphics accelerators and hardware sound capabilities other machines had, the software made more than up for it. This first Macintosh was the Mac 128K and its succes spurned more advanced models of this compact Mac, namely the Macintosh 512K, the Macintosh Plus, and the Macintosh SE-series. While the development of the Macintosh happened around 1984, way before I was at an age I could understand computers, I do feel some kind of kinship with the compact Macintosh: the first computer my parents owned was a Macintosh Plus. It was later joined by a 20MB SCSI hard disk, and on that machine I wrote my first Basic-programs. Back when I still lived in the Netherlands, I actually bought a broken SE/30 machine and converted that into a Linux-server while still being able to run Mac-software. I left that machine in the Netherlands, however, and here in Shanghai, I have no classic Apple hardware anymore. While obviously I don’t really need a Mac Plus anymore for my day-to-day life, I did like the idea of having one available for when I felt nostalgic. Maybe I could get a tiny bit of the Macintosh experience back by building a small one myself. Seeing I already have some experience with making smaller versions of old hardware, why not try to apply that process to the venerable Mac Plus as well? DisplaySo, what to use when building something like this? One of the ways that sprung to mind was to take a Raspberry Pi or something, add a 2.5” LCD, add an emulator like PCE or MiniVMac, 3d-print an enclosure and call it a day. But I didn’t feel that would do my idea justice: not only would it be too big for my tastes, it also would be too easy: With the original Mac 128K, even while the end result was seen as underpowered, the hardware designers that built it did their best to pull a few nice tricks to save cost. Just assembling off-the-shelf commodity hardware into a replica felt like I would be doing the original design a disservice. So off to Taobao for some more exotic components I went! I decided to start with the display. The Mac had a fairly high-resolution display for its time, and finding a display to replicate that had a pretty high priority. In general, when it comes to displays available on the Chinese electronic market, there’s a large choice available. Unfortunately, the ‘large choice’ seems to consist of either higher-resolution but larger screens, or alternatively tiny but lower-resolution screens. Ideally, I needed a resolution of 512x342 pixels; that is the native Mac resolution and on a screen like that, I would be able to display everything without rescaling. Unfortunately, screens with this resolution don’t readily exist; the next best resolution up would be something like 640x480. Screens with that resolution, for some reason, tend to start out pretty big: the smallest viable one I could find was about 3.5”. So unfortunately, I would have to do some downscaling if I wanted to make the Mac as small as possible. After deciding it would be okay to downscale a bit, I had access to a fair amount more displays. One of the displays that popped up pretty quickly was the x163qln01, an 1.63” OLED screen made by AUO. While slightly expensive (about US$25 per screen), this display has good availability on Taobao and a datasheet that at least documents the pinouts, dimensions and power source requirements. This display seems to be made for certain Android smartwatches, and with some mangling of search terms, Google even spat out some initialization sequences I could use. The only problem (well, aside from the connector that had pins a mere 0.5mm apart) was that the display did not use a parallel or SPI interface, but a MIPI interface. I’d have to tackle that later on. With the choice of display made, I could move on to the processor. I grabbed an ESP32-Wrover module for this. This module contains an ESP32 (a WiFi chip with 2 32-bit CPUs running at 240MHz and about half a megabyte of RAM), 4MiB of flash and 4MiB of PSRAM memory. My guess was that the 2 CPU cores would be fast enough to emulate a Mac and that I could use the 4MiB of PSRAM memory to give the Mac its RAM. While 4MiB of flash is not that much, it should be enough for the emulator plus a small-ish hard disk with the system software and some programs. Also, it helps that I work for Espressif, making me pretty familiar with the hardware; what also helped was that I could just grab some modules from work instead of having to buy them and then wait for them to arrive. With that, I was mostly set - the OLED still needed some components to be powered so the component count was increased by some LDO and other power supply chips. The Mac also needed sound so I sourced a cheap amplifier chip and speaker, and for power and debugging I pulled a common FT232 module out of a drawer somewhere. All these components are pretty small and allow me to scale down the enclosure, resulting in a model that would be a little bit bigger than 1/6th of a real Mac. Driving the displayWhile I had nothing to complain about the resolution, size and brightness of the display, actually getting pixels to it was more problematic. The MIPI interface it has was not supported by the ESP32 silicon so I would have to find another way to interface with it. The MIPI DSI interface is a standard developed by the MIPI Alliance and not public; as a hobbyist, I’d have to piece together the details from leaked documents and probing of existing devices. Luckily, a year or two ago Mike Harrison reverse engineered the MIPI DSI interface used to control iPod displays (1, 2, 3, 4, 5, website) and also managed to find some copies of the specifications. This made my life a lot easier: it helps to at least know what to send to the display. While there is a lot more to it (and you should really watch the above videos if you want to know what), the physical layer of the MIPI protocol is pretty simple to explain. The MIPI protocol uses four wires in total: two data- and two clock-lines. The MIPI protocol has two modes of signalling: Low Power (LP) mode and High Speed (HS) mode. ​ In Low Power mode, the wires are used separately to transmit some control data structures as well as indicate certain commands that have direct effect on the physical receiver on the other side. The voltage swing in this mode is pretty large compared to the high speed mode: voltages are either around 1.2 volt for a high signal, or around 0 volt for a low signal. Because low speed mode has more signal states, it does things like tell the receiver to enter or exit high speed mode. In the diagram above, the blue lines indicate Low Power communication. In High Speed mode, the two clock lines (CLKP/CLKN) as well as the two data lines (DP/DN) work as differential lines, with one line always being the opposite as the other one. The receiver detects the difference between the two lines, and deduces the value being sent from this: a 1 if DP is higher, a 0 if DN is higher. High-speed mode, as the name implies, allows for very quick data transfers with clocks up to 1.5GHz. The trick the standard used to get this done without too much EMC and power use is to use very low voltages in this mode: the voltages on the pairs average to about 200mV, with variations of +/- 100mV per line to indicate the ones and zeroes. In the above diagram, the red bits are done in high-speed mode. For the actual data transfer, in high speed mode the interface can essentially be seen as a somewhat weird and differential SPI interface: there is a clock and data path, and every clock tick, the value of the data is clocked into the interface. A change from SPI, apart from the fact that the signals are differential, is that a data bit is clocked in whenever the CLK lines change state, instead of only on e.g raising edges. Another difference is that the start of a transfer is detected not by a /CS line going low, but by in-band signalling: every transmission starts with one unique binary ‘magic word’ and the receiver detects this value to decide when a transmission starts. In order to interface this with the ESP32, I’d have to do some level shifting. I wanted to run the ESP32 from a 3.0V power source, so all GPIOs would also be 3.0 or 0 volt. To adapt this to the signal levels of the MIPI interface, I opted for the most cheap solution: just use some resistor divider networks. To figure out the resistor values, I effectively made equations for the three voltage output states that interested me (1.1V for Low Power high, 0.07V for High Speed low, 0.33V for High Speed high; voltages chosen to stay in-spec for most situations) and the three input states that should generate them. Using some math, I ended up at some equations. I could theoreticaly work out those equations by hand, but eventually decided to throw them into WolframAlpha which gave me the needed resistor values. 123456789101112 3VG -R1--+ R3G -R2--+ --+----&gt; R4 GNDR4*(1.9/R1+1.9/R3)=1.1, (1/(1/R4+1/R1+1/R2))*(2.93/R3)=0.07, (1/(1/R4+1/R1))*2.67*(1/R3+1/R2)=0.33, R2=1000R1=280, R2=1K, R3=3K6, R4=150 At that time, I figured I could also cheat a bit: because the lines are differential in high-speed mode, the display will only look at the difference between the two lines to deduce the data sent. This means that I can save a GPIO by holding one of the lines at a fixed voltage, making the other line higher and lower as needed. To do this, I needed a second type of resistor network: 1234567891011 3V R3G -R1--+ --+----&gt; R4 GNDR4*(1.9/R1+1.9/R3)=1.1,(1/(1/R4+1/R1))*(2.8/R3)=0.2,R4=150R1=320, R3=1500, R4=150 Another thing to solve was the clocking scheme. Normal SPI clocks in a bit on a raising edge of the clock line. (Or a falling one, depending on the configuration.) MIPI clocks in a bit on both the raising as well as the falling edge of the clock signal. While the ESP32s hardware SPI unit cannot by itself generate a signal like this, we can convert from one to another by using a simple D-type flipflop with its inverted output connected to its input. Every clock pulse on the input will change the level of the output, exactly as is needed here. SchematicWith the display hardware fixed up, the hardest part of the hardware design was done. Now we only need to add the rest. First up, the power supply. This is pretty simple: I feed the entire design from 5V from an USB-to-serial converter that I also can use as a debugging/programming interface. That voltage is taken to generate the +4.6V, -3.4V and 1.8V the OLED screen needs, as well as the 3.0V to feed the ESP32. The +4.6V and -3.4V are generated by a TPS65631 chip, and a reference schematic for that was included in the datasheet for thr OLED. The other voltages are generated by a pair of simple LDOs. The Macintosh also had sound. The quality isn’t that good by modern standards (22KHz, 8-bit) but the sounds that various software programs make are by now quite iconic, so I couldn’t forego a speaker here. The ESP32 has a built-in 8-bit DAC, and that is used to render the analog soundwaves that the emulator generates. That then gets put into a NS8002 which is a 2W class-AB audio amplifier housed in a small SOIC8 package. It is cheap, needs very few support components and makes more than enough noise for the tiny Mac to attract attention. One of the things that made the Macintosh so revolutionary is that it was one of the first commercial computers that came with a mouse. The Macintosh team thought so highly of the mouse that essentially the entire OS is based around mouse-controlled UI elements, and unlike, for example, an IBM PC, it is entirely possible to control the entire Macintosh with only a mouse. Obviously, my tiny Mac should also have such an important peripheral. I still do remember the original ball mouse that came with the early Macintoshes, and I do not quite relish the need to get the gunk off the little rollers every so often; there is a reason optical mice have replaced these mechanical devices entirely. This also has the advantage that parts for these new-fangles optical mice are quite easy to obtain: I did not need to spend much effort at all to locate a source of ADNS9500 gaming mouse sensors plus the corresponding optics, for instance. The other nice thing is that an optical mouse sensor is a pretty deeply integrated device: a mouse sensor only needs a few other external components to function, and the schematic reflects this. There are a few capacitors for voltage stabilization, an MOSFET (copied straight from the datasheet) to switch the laser diode, and some other jellybean parts. The mouse sensor communicates using a four-wire SPI signal, and I’ve re-used one of these wires to also send the mouse button signal over: the MISO pin is pulled down with a fairly strong pulldown when this button is pressed. The value of this pulldown resistor is not enough to stop the mouse sensor from communicating, but it is enough to overcome the pullup-resistor that normally pulls up the line, so when the sensor tristates the MISO line, the ESP32 can detect if the button is pressed. Finally, the OLED screen needs connecting. We already did all the hard work calculating all the resistor values, so the schematic should be more or less self-explanatory. The chip added is a D-type flipflop and is used to halve the clock rate: as mentioned before the MIPI standard needs a new data bit every time the clock polarity inverts, while the ESP32 can only send out a new one on a raising or falling edge. With the schematic drawn, I moved on to the PCB artwork. The display I chose was meant to be mounted to its controlling PCB, with the connector on the backside of that PCB. While that would not leave much room for the other components, I still wanted to put all the other components on the other side. It’s a good thing I have a good pair of eyes and a hot-air rework station: this allowed me to use 0603 components which made everything fit cleanly on the limited PCB space. Especially the connector for the display and the QFN OLED power supply chip would be pretty hard to do with a normal soldering iron. ​ For the mouse sensor and attached components, I figured out using a PCB would use up too much space. Instead, I opted to solder all components on the sensor itself, freeform style. This way, everything should be able to fit in the mouse. ​ Software​ Now obviously, the software is a fairly big element of this build: the entire Macintosh needs to be emulated. The Macintosh, however, is not that complicated a machine. It essentially consists of the 68000 microcontroller, a Zilog Z8530 serial communications controller that controls the serial port, a 6522 VIA for some internal input and output and for interfacing with the keyboard and some random PALs containing the logic for the display and sound. There also is an Integrated Woz Machine-chip to interface with the floppy drive. This is a fairly complicated chip; however I was not planning to emulate a floppy so for emulation it would be enough to emulate an IWM that always returns that there’s no floppy in the drive. Instead, my plan was to fully emulate the NCR 5380 SCSI chip, connected to an emulated SCSI hard disk that would read from the onboard flash of the ESP32-Wrover module. Furthermore, there are very few programs that attempt to access this hardware directly: programmers for the Mac were told from the start to use the OS-level hardware abstraction layers in order to stay compatible with later versions of the Mac hardware. In general, this means that when I succeeded emulating the hardware to a standard where the OS boots and stays happy, most programs would also run without complaints. Because of this I decided I might as well program the emulator from scratch. Well, not entirely from scratch; the 68000 is a fairly complex beast and I didn’t feel like reinventing that particular wheel. Instead, I looked around on the Internet, and MAME had a nice and quick C-based 68K emulator called Musashi that fit the bill nicely. It needed some slight mangling to put the lookup tables for the opcodes into flash instead of RAM, but otherwise it didn’t need much to port to the ESP32. However, I wasn’t planning on developing the entire thing on the ESP32: while the chip has OpenOCD support allowing for a fair amount of debugging, the upload/test/fix/upload/… cycle would get pretty tedious. Instead, I decided to develop the thing on my Linux-machine first, keeping in mind the limits the ESP32 would eventually give me. So I went to work, using the datasheets for the various chips, the Linux-68K notes for the machine, as well as bits and pieces of the Inside Macintosh series that were floating around on the Internet. When I couldn’t find out from these what to do, I still had the option to sneak a peek under the hood of other open-source emulators. Armed with all that, gcc as the C-compiler and libsdl as the library to get graphics going, I set to work. Long story short, some time later I ended up having a basic but mostly functional MacPlus emulator: mouse, video, SCSI hard disk and sound all worked: Because my hardware wasn’t done yet, I decided to port my emulator to an ESP-Wrover-Kit devboard. I had access to a few of these boards anyway, and apart from the Wrover module I was going to use anyway, it also had a nice 320x240 display I could use to see if video works. After some tweaking, the Mac emulator actually ran fairly well on this board; it usually comes pretty close to the 7.8MHz the Mac Plus normally runs at. (Actually, 7.8MHz would be slightly faster than a Mac Plus; because the frame buffer and sound system in the real thing eat up some of the memory cycles, the actual effective frequency could be as much as 35% lower.) Obviously, getting the emulator working on a devboard is a nice step along the way, but in the end, the thing needs to run on the screen that I bought, not the devboard screen. And hold on a second, the devkit screen is 320x240 and cuts off a fair chunk of the Mac screen. The display I intend to use is 320x320 and as such only larger vertically: how am I going to get the 512x342 Mac screen displayed on it? There’s one way to put 512x342 pixels onto a 320x320 screen, and that is scaling. Effectively, you take an image, then squish it to make it smaller, then you display it. However, scaling can be done in multiple ways and especially with a black-and-white image generated by an OS that assumes every pixel it set results in a clearly distinguishable point of light on the screen, there are multiple ways to do it badly. Effectively, I would like to lose as little resolution as possible. This means I needed to increase the resolution of my OLED. But how do you do that? I can hardly open up the OLED screen and squish some more pixels in there. However, I don’t need to; the OLED display already has three times as many pixels as advertised. The reason for this is that the OLED screen is a color one: for each virtual ‘pixel’, it has a red, a green and a blue subpixel. Additionally, in this specific screen, the subpixels are laid out in triangles. To illustrate this, here’s a close-up of the screen, with three pixels lit: As you can see, the pixels are triangle-shaped sets of three subpixels; depending on the column they are on, the triangles either point up or down. This effectively means that our subpixel screen resolution is a nice 480 x 640 pixels instead. While still not entirely adequate for displaying 512x342 pixels, the difference is so small that with a small bit of well-chosen scaling the display looks as readable as an 1.63” display showing a GUI meant for a 9” screen will ever be: EnclosureSo now I had a display, software that could emulate a Macintosh Plus fairly well, plus a microcontroller it could run on. What’s still missing? A nice box to put it in, obviously! I decided to 3d-print one on the nice Formlabs 1+ SLA printer my work has. To do this, I first needed a model. I wanted to build one from scratch. Obviously, to do this it would be best if I had a real Macintosh Plus at my disposal. I actually have one in my posession, but it was half a continent away… Luckily, I could get my hands on the next best thing: some kind soul uploaded the dimensions of an original Mac 128K (which has almost the same case as the Plus) to the iFixit wiki. I still do all my 3d modeling in OpenScad, and after some sweating and cursing to get all the curves looking like they should, I had a nice model of an 1-to-6-scale Mac. The mouse was also created from the iFixit images, but because it needed to fit the (relatively large) optical mouse sensor, unfortunately it couldn’t be scaled to 1/6th of the real thing. The scale is more like 2/5th, making it seem somewhat large next to the tiny Mac but also making it way more usable for non-scaled-down human fingers. So now all that remained was to print the thing. I exported the design as various STL files and used the Formlabs 1+ to print them. This went fairly well, althought the resin was somewhat old so I put a few more supports than the default in to make sure I wouldn’t get a mis-print. The end result came out pretty nice; the only regret I have is that I didn’t put locking clips for the two halves in the design. I eventually worked around that by just sealing the two halves together using a drop of superglue. ResultSo, I had all the parts and I just needed to click them together. The PCB slots in the front of the case, where a few clips hold it in. The usb-to-serial converter, used as an upload mechanism and a power supply, slot into the back bit and is also held by a few clips. I forgot to make something to hold the speaker in, but some superglue can easily affix it inside the case. Finally, the mouse is connected using a bundle of thin wires. (And yes, they kind-of clash with the color scheme… as soon as I find a nicer, thin multi-core cable I’ll replace it with that.) Now, when designing things on a computer in order to have them materialize in full later on, like what happens when you finally receive those PCBs from the factory or when your 3d-printer finishes printing that design you worked for weeks on, is the scale of the thing. Obviously, I knew that all sizes would be 1/6th of a real Mac, but only when everything was put together and I saw the thing in real life, the implications of this showed. The Mac truly is tiny! And even with its minute size and lack of a keyboard, it does run most of the things the Mac is well-known for. Here is a demonstration. The first 20 seconds are the memory test, and I know from experience the test lasting this long is not a bug: it took our original Mac Plus that long to boot as well after we upgraded it. So, what good is this Mac Plus in the end? Admittently, while I had a blast making it, without a keyboard it can’t really serve a real purpose. Also, it has no connectivity to speak of: I planned to make it do AppleTalk over WiFi, but I failed because of some weirdnesses I couldn’t emulate right in the serial controller chip of the original Mac. Still, with the project finished in the state it is, I can finally live my lifelong dream to have a Mac on my desk displaying the original After Dark flying toasters: As always, this project is open-source, and the PCB artwork as well as the case design and the firmware are up on Github. Everything is licensed under the Beer-Ware license so you can mostly do with it what you want. If you ever use it in something, I’d really appreciate a [note](http://spritesmods.com/?art=contact&amp;af=Miniature Macintosh Plus), however.","categories":[{"name":"搬运","slug":"搬运","permalink":"https://ljweb.xyz/categories/%E6%90%AC%E8%BF%90/"}],"tags":[{"name":"diy","slug":"diy","permalink":"https://ljweb.xyz/tags/diy/"}]},{"title":"锂电池电压测量电路设计","slug":"锂电池电压测量电路设计","date":"2021-11-24T17:36:05.000Z","updated":"2022-02-16T14:10:43.468Z","comments":true,"path":"2021/11/24/锂电池电压测量电路设计/","link":"","permalink":"https://ljweb.xyz/2021/11/24/%E9%94%82%E7%94%B5%E6%B1%A0%E7%94%B5%E5%8E%8B%E6%B5%8B%E9%87%8F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"参考： &emsp;&emsp;1.锂电池电压测量电路设计 - 立创EDA开源硬件平台 (oshwhub.com) &emsp;&emsp;2.锂电池电压测量电路设计 – 瑞生网 (rationmcu.com) &emsp;&emsp;先补充一下锂电池的基本知识 &emsp;&emsp; 锂电池在充满电的时候，是4.2V；在用完电的时候，不是0V，而是2.7V左右，每个厂家制作的锂电池，略有差异。鉴于锂电池材料的局限性，电压超过4.2V，会发生危险，比如燃烧；电压低于2.7V左右，会造成无法再次充电，总之…锂电池电压过高和过低，都会造成永久损坏。所以，我们的产品在使用锂电池的时候，需要时刻监测锂电池电压。 &emsp;&emsp;充电的时候，不要超过4.2V，这个要求，需要产品中加入充电管理芯片，充电管理芯片会自动在4.2V的时候切断充电。放电的时候，也就是产品在正常使用的时候，不要让锂电池电压低于2.7V，比如，在2.7V的时候，自动强制关机。 &emsp;&emsp;那么，锂电池电压监测电路应该怎么设计呢？ &emsp;&emsp;如上图所示，应该是初学者最先想到的办法。不过，仔细分析后会发现，有大问题，我们来分析一下。 &emsp;&emsp;VBAT连接到锂电池正极，通过两个电阻分压，连接到单片机的ADC引脚。ADC测到的电压，就是锂电池电压的一半。因为锂电池的电压范围大概在2.7V到4.2V之间，所以ADC引脚的电压会在1.35~2.1V之间，不会超过普通单片机的3.3V电压，看起来很合理，不过，当产品处于关机状态时，我们以为锂电池就不耗电了，其实，通过电路可以发现，锂电池其实还在通过2个10k的电阻耗电。随着时间的推移，该产品放着放着电就减少了，而且当电池电压减少到2.7V以下时，就可能无法充起电来了。 &emsp;&emsp; 我在国外的一款产品上，看到了这样的一个电路，当然，已经把它使用到我的产品当中。 &emsp;&emsp;上面电路，很巧妙的解决了这个问题，代价是电路板上多了1个MOS管和2个电阻，CTRL引脚是单片机的一个普通引脚，在单片机断电的时候，要求是高阻态，否则也会耗电！·这里加MOS管并不是用来控制“是否要测量电池电压”，而是为了在产品关机的时候，不要让锂电池电池的电压通过两个分压电阻。 &emsp;&emsp;此时，还有个问题要解决。 &emsp;&emsp;产品在正常使用的过程中，当电池电压小于3.3V时，LDO的输出电压，就不再是3.3V了，随着电池电压的减小，LDO的输出电压也会减小，此时… 如果一直使用3.3V作为基准来测量电池电压，就会出现错误，所以，需要使用有基准电压引脚的单片机，或者有“内部参考电压”+“内部测量通道”功能的单片机 用基准电压引脚计算电池电压，这个大家都清楚，我重点说一下“内部参考电压”+“内部测量通道”这个功能。 &emsp;&emsp;简单来说，有了“内部参考电压”+“内部测量通道”之后，我们就可以直接通过内部测量通道得到精确的VDD电压，而不必使用基准电压芯片了，毕竟，基准电压芯片也挺贵的，还得在电路板上占个地方，以及多几分钱的焊接费用。 &emsp;&emsp;下面，我们以STC8G系列单片机为例来说一下。 &emsp;&emsp;STC8G的ADC第15通道，用来测量内部参考电压源，内部参考电压为1.19V，通过测量它的值，反推出VDD值。 123456789101112131415161718192021222324252627282930313233343536373839unsigned int VDDA; // VDDA的电压值 单位毫伏unsigned int *BGV; // 内部参考电压值 单位毫伏//ADC初始化void ADC_Init(void)&#123; BGV = (int idata *)0xEF; ADCCFG = 0X2F; // 设置ADC时钟 = 24000000/2/16/512 = 1465Hz 转换结果右对齐&#125;unsigned int ADCRead(void)&#123; unsigned int res; ADC_CONTR |= 0X40; // 启动AD转换 _nop_(); _nop_(); while(!(ADC_CONTR&amp;0X20)); // 查询ADC完成标志 ADC_CONTR &amp;= ~0X20; // 清除完成标志 res = (ADC_RES&lt;&lt;8)|ADC_RESL; //读取ADC结果 return res;&#125;void Fetch_VDDA(void)&#123; unsigned int res=0; unsigned char i; ADC_CONTR = 0X8F; // 使能ADC模块 并选择第15通道 ADCRead(); ADCRead(); for(i=0;i&lt;8;i++) &#123; res+=ADCRead(); &#125; res&gt;&gt;=3; // 读取8次 取平均值 VDDA = (unsigned int)(1023L**BGV/res); // 得出的结果单位是毫伏&#125;上面代码，获得了真实的VDDA值，然后就可以计算出真实的电池电压。 本文摘自瑞生网，点击查看原链接","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ljweb.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"大功率直流有刷电机驱动设计","slug":"大功率直流有刷电机驱动设计","date":"2021-11-24T17:09:04.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/24/大功率直流有刷电机驱动设计/","link":"","permalink":"https://ljweb.xyz/2021/11/24/%E5%A4%A7%E5%8A%9F%E7%8E%87%E7%9B%B4%E6%B5%81%E6%9C%89%E5%88%B7%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"参考： &emsp;&emsp;1.IR2104驱动原理_ChenYX的博客-CSDN博客 &emsp;&emsp;2.4833N，MOS， 直流电机驱动板 - 立创EDA开源硬件平台 (oshwhub.com) &emsp;&emsp;3.BTN8982双路大电流电机驱动 - 立创EDA开源硬件平台 (oshwhub.com) &emsp;&emsp;4.大电流双路直流电机驱动 H桥 MOS管 【低创】 【高性价比】 - 立创EDA开源硬件平台 (oshwhub.com) &emsp;&emsp;5.BTN7971B模块_大功率H桥驱动器 - 立创EDA开源硬件平台 (oshwhub.com)","categories":[{"name":"智能车","slug":"智能车","permalink":"https://ljweb.xyz/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://ljweb.xyz/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"linux学习笔记","slug":"linux学习笔记","date":"2021-11-24T16:00:10.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/24/linux学习笔记/","link":"","permalink":"https://ljweb.xyz/2021/11/24/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考： Linux常用命令_Demon的博客-CSDN博客_linux常用命令","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ljweb.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"git学习笔记","slug":"git学习笔记","date":"2021-11-22T17:37:08.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/22/git学习笔记/","link":"","permalink":"https://ljweb.xyz/2021/11/22/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考：Git学习笔记 (fushaolei.github.io) 🤳常用指令Git学习笔记 (fushaolei.github.io) 指令 说明 git init 初始化 git add . 将修改放入暂存区 git status 查看状态 git log 可以查看有几个版本提交到仓库里 git reset --hard 版本号 版本回退，hard强制回退，soft的话会保留修改 git stash 将修改保存起来 git stash save &quot;xxx&quot; 将修改保存起来，并设置这个保存的标签 git stash apply stash@&#123;x&#125; 将修改移出来 git branch -vv 查看本地分支是否与远端分支建立了连接 git push origin &lt;分支名&gt;:&lt;分支名&gt; 仅仅将本地分支推送到远端分支， 注意:这个操作只是单纯的把本地的分支推送到远端,尚未建立连接 git remote 查看远程库的信息，用git remote -v可以看到更详细的信息 git pull --rebase origin master 和远程仓库进行一个同步","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ljweb.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/tags/%E6%95%99%E7%A8%8B/"},{"name":"git","slug":"git","permalink":"https://ljweb.xyz/tags/git/"}]},{"title":"使用GitHubAction实现hexo在线写作","slug":"使用GitHubAction实现hexo在线写作","date":"2021-11-22T16:56:51.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/22/使用GitHubAction实现hexo在线写作/","link":"","permalink":"https://ljweb.xyz/2021/11/22/%E4%BD%BF%E7%94%A8GitHubAction%E5%AE%9E%E7%8E%B0hexo%E5%9C%A8%E7%BA%BF%E5%86%99%E4%BD%9C/","excerpt":"","text":"参考：GitHub Action + Hexo实现在线写作_磊少1999的博客-CSDN博客 &emsp;&emsp;建一个新的仓库给hexo放源文件，然后使用GitHub Action： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# workflow namename: Hexo Blog CI# master branch on push, auto runon: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # from: https://github.com/actions/setup-node - name: Setup Node.js 12.x uses: actions/setup-node@master with: node-version: &quot;12.x&quot; - name: Setup Hexo Dependencies run: | npm install hexo-cli -g npm install - name: Setup Deploy Private Key env: HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRIVATE_KEY &#125;&#125; run: | mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts - name: Setup Git Infomation run: | git config --global user.name &#x27;&lt;你的用户名&gt;&#x27; git config --global user.email &#x27;&lt;你登录的email&gt;&#x27; - name: Deploy Hexo run: | hexo clean hexo generate hexo deploy","categories":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/tags/%E6%95%99%E7%A8%8B/"},{"name":"git","slug":"git","permalink":"https://ljweb.xyz/tags/git/"}]},{"title":"hexo首行缩进不显示解决方法","slug":"hexo首行缩进不显示解决方法","date":"2021-11-21T13:57:20.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/21/hexo首行缩进不显示解决方法/","link":"","permalink":"https://ljweb.xyz/2021/11/21/hexo%E9%A6%96%E8%A1%8C%E7%BC%A9%E8%BF%9B%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"&emsp;&emsp;通过Markdown写的文章转换成HTML后首行没有缩进2格，即使在Typora中显示有缩进（自己多敲了几个空格或者Tap键），这种原因是Markdown对中文的支持不全导致的。 参考： Markdown首行缩进解决方法实例_DC-CSDN博客 解决方法: 1用 &amp;emsp; 代替空格","categories":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/tags/%E6%95%99%E7%A8%8B/"},{"name":"typora","slug":"typora","permalink":"https://ljweb.xyz/tags/typora/"}]},{"title":"立创训练营esp32数码管时钟","slug":"立创训练营esp32数码管时钟","date":"2021-11-21T09:05:11.000Z","updated":"2022-02-16T14:10:43.468Z","comments":true,"path":"2021/11/21/立创训练营esp32数码管时钟/","link":"","permalink":"https://ljweb.xyz/2021/11/21/%E7%AB%8B%E5%88%9B%E8%AE%AD%E7%BB%83%E8%90%A5esp32%E6%95%B0%E7%A0%81%E7%AE%A1%E6%97%B6%E9%92%9F/","excerpt":"","text":"&emsp;&emsp;最近参加了学校实验室的立创训练营项目，项目是做一个物联网的时钟，还是比较简单的一个项目，使用的是ESP32-C3模组，两个四位数码管来显示时间，MAX7219驱动数码管，DS1302时钟芯片提供时间，然后还有五个按键。一个程序下载按键，一个RST按键，还有三个功能按键。 &emsp;&emsp;硬件上来说还是很简单的。我在此基础上添加了锂电池充放电管理，使用的是TP4054这颗充电IC外围电路非常少，因为目前我还不会其他的充电电路，就只能先用这个了，这颗芯片带一个充电指示引脚，连一颗LED就能指示充电了。我还加了个SHT30温湿度传感器，然后把DS1302换成了PCF8563，这颗时钟芯片与单片机使用I2C通信，程序设计上要稍微复杂些，SHT30也是用 I2C 通信的， I2C 确实比较神奇，我复用了两个引脚来连接这两颗芯片。 &emsp;&emsp;这次使用立创EDA进行电路、PCB设计：项目开源链接 &emsp;&emsp;软件上本来打算用ESP-IDF的，可是配置起来麻烦的很，所以最后我还是用我目前比较熟悉的arduino来实现的。打算以后有时间再来用ESP-IDF。 1.arduino参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;WiFi.h&gt;#include &lt;time.h&gt;#include &quot;NTPClient.h&quot;#include &lt;Ds1302.h&gt;const char* ssid = &quot;ssid&quot;;const char* password = &quot;password&quot;;int CLK = 7;int CS = 6;int DIN = 4; //这里定义了那三个脚int sw1=18;//拨轮按键int sw2=19;int sw3=10;int sec; int n=10;#define battery 0WiFiUDP ntpUDP; NTPClient timeClient(ntpUDP, &quot;ntp1.aliyun.com&quot;, 60*60*8, 30*60*1000); void smgdispaly() &#123; if(sec!=timeClient.getSeconds())&#123; int h1,h2,m1,m2,s1,s2; h1=timeClient.getHours()/10; h2=timeClient.getHours()%10; m1=timeClient.getMinutes()/10; m2=timeClient.getMinutes()%10; s1=timeClient.getSeconds()/10; s2=timeClient.getSeconds()%10; Write_Max7219(0x0f, 0x00); //显示测试：1；测试结束，正常显示：0 Write_Max7219(1,h1); Write_Max7219(2,h2); Write_Max7219(4,m1); Write_Max7219(5,m2); Write_Max7219(7,s1); Write_Max7219(8,s2); sec=timeClient.getSeconds(); &#125; &#125;void batterydisplay()&#123; float analog_value = 0; analog_value = analogRead(battery); delay(1000); Serial.printf(&quot;Current Reading on Pin(%d)=%f\\n&quot;,battery,analog_value*4.2/2910); &#125;void switchkey()&#123; if(digitalRead(sw2)==LOW)&#123; delay(10); if(digitalRead(sw2)==LOW)&#123; Serial.println(n); Write_Max7219(0x09, 0xff); Write_Max7219(0x0a, n++); if(n&gt;=15) n=15; &#125; &#125; if(digitalRead(sw3)==LOW)&#123; delay(10); if(digitalRead(sw3)==LOW)&#123; Serial.println(n); Write_Max7219(0x09, 0xff); Write_Max7219(0x0a, n--); if(n&lt;=0) n=0; &#125; &#125;&#125;void setup() &#123; // put your setup code here, to run once: Serial.begin(115200); pinMode(CLK,OUTPUT); pinMode(CS,OUTPUT); pinMode(DIN,OUTPUT); //让三个脚都是输出状态 pinMode(battery,INPUT); pinMode(sw1,INPUT_PULLUP); pinMode(sw2,INPUT_PULLUP); pinMode(sw3,INPUT_PULLUP); Init_MAX7219(); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi connected&quot;); Serial.println(&quot;IP address: &quot;); Serial.println(WiFi.localIP()); timeClient.begin(); sec=timeClient.getSeconds(); Serial.println(timeClient.getFormattedTime());&#125;void loop() &#123; // put your main code here, to run repeatedly: timeClient.update(); smgdispaly(); switchkey(); delay(50);&#125;void Delay_xms(unsigned int x)&#123; unsigned int i,j; for(i=0;i&lt;x;i++) for(j=0;j&lt;112;j++);&#125;//--------------------------------------------//功能：向MAX7219写入字节//入口参数：DATA //出口参数：无//说明：void Write_Max7219_byte(unsigned char DATA) &#123; unsigned char i; digitalWrite(CS,LOW); for(i=8;i&gt;=1;i--) &#123; digitalWrite(CLK,LOW); if(DATA&amp;0X80) digitalWrite(DIN,HIGH); else digitalWrite(DIN,LOW); DATA&lt;&lt;=1; digitalWrite(CLK,HIGH); &#125; &#125;//-------------------------------------------//功能：向MAX7219写入数据//入口参数：address、dat//出口参数：无//说明：void Write_Max7219(unsigned char address,unsigned char dat)&#123; digitalWrite(CS,LOW); Write_Max7219_byte(address); //写入地址，即数码管编号 Write_Max7219_byte(dat); //写入数据，即数码管显示数字 digitalWrite(CS,HIGH); &#125;void Init_MAX7219(void)&#123; Write_Max7219(0x09, 0xff); //译码方式：BCD码 Write_Max7219(0x0a, 15); //亮度 Write_Max7219(0x0b, 0x07); //扫描界限；4个数码管显示 Write_Max7219(0x0c, 0x01); //掉电模式：0，普通模式：1 Write_Max7219(1,0xa); Write_Max7219(2,0xa); Write_Max7219(3,0xa); Write_Max7219(4,0xa); Write_Max7219(5,0xa); Write_Max7219(6,0xa); Write_Max7219(7,0xa); Write_Max7219(8,0xa); delay(100);&#125; 2.ESP-IDF正在尝试中…… 参考：快速入门 - ESP32 - — ESP-IDF 编程指南 latest 文档 (espressif.com)","categories":[{"name":"arduino","slug":"arduino","permalink":"https://ljweb.xyz/categories/arduino/"}],"tags":[{"name":"diy","slug":"diy","permalink":"https://ljweb.xyz/tags/diy/"},{"name":"arduino","slug":"arduino","permalink":"https://ljweb.xyz/tags/arduino/"},{"name":"C语言","slug":"C语言","permalink":"https://ljweb.xyz/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"OpenMv+arduino_uno实现循迹","slug":"OpenMv-arduino-uno实现循迹","date":"2021-11-21T08:36:55.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/21/OpenMv-arduino-uno实现循迹/","link":"","permalink":"https://ljweb.xyz/2021/11/21/OpenMv-arduino-uno%E5%AE%9E%E7%8E%B0%E5%BE%AA%E8%BF%B9/","excerpt":"","text":"OpenMv： 参考：巡线小车 · OpenMV中文入门教程 1.OpenMv(main.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335&#x27;&#x27;&#x27;功能描述 完整功能包括： * 直线巡线 * 直角转弯判定 (左转or右转) * T字形路口判定 * 十字形路口判定 其中Ｔ字形跟十字形可以用作四轴悬停的参考点。原理介绍 算法的主要核心在于，讲整个画面分割出来5个ROI区域 * 上方横向采样 * 中间横向采样 * 下方横向采样 * 左侧垂直采样 * 右侧垂直采样 通过判断5个图片的组合关系给出路口类型的判断&#x27;&#x27;&#x27;import sensorimport imageimport timeimport mathimport pybfrom pyb import Pin, Timer, UART,LEDfrom GeometryFeature import GeometryFeatureLED(4).on()is_debug = True#--------------感光芯片配置 START -------------------DISTORTION_FACTOR = 1.5 # 设定畸变系数IMG_WIDTH = 64IMG_HEIGHT = 64def init_sensor(): &#x27;&#x27;&#x27; 初始化感光芯片 &#x27;&#x27;&#x27; sensor.reset() sensor.set_pixformat(sensor.GRAYSCALE) sensor.set_framesize(sensor.B64X64) # 分辨率为B64X64 sensor.skip_frames(time=2000) sensor.set_auto_gain(False) # 颜色追踪关闭自动增益 sensor.set_auto_whitebal(False) # 颜色追踪关闭白平衡init_sensor()#--------------感光芯片配置 END -------------------def ternleft(): uart.write(&#x27;G&#x27;) time.sleep_ms(650) uart.write(&#x27;L&#x27;) time.sleep_ms(600)def ternright(): uart.write(&#x27;G&#x27;) time.sleep_ms(650) uart.write(&#x27;R&#x27;) time.sleep_ms(590)#--------------串口UART部分 START -------------------uart = pyb.UART(3,115200,timeout_char = 1000) #串口初始化def get_symbol(num): &#x27;&#x27;&#x27; 根据数值正负，返回数值对应的符号 正数：‘+’， 负数‘-’ 主要为了方便C语言解析待符号的数值。 &#x27;&#x27;&#x27; if num &gt;=0: return &#x27;+&#x27; else: return &#x27;-&#x27;def data_format_wrapper(yaw_angle, sum_x, sum_y, cx_mean, cx, cy, is_left_angle, is_t, last_y): &#x27;&#x27;&#x27; 根据通信协议封装数据 TODO 重新编写通信协议 与配套C解析代码 yaw_angle,sum_x, sum_y 没有用到 cx_mean: roi 1 2 3 对应的bolb中心的x坐标加权平均， 如果没有就补32 都没有就赋值为原来的值 cx : roi 1 3 blob 中心坐标的加权平均， 如果一方丢失， 就赋值为另外一个 都没有就赋值为原来的值 cy : roi 4 5 blob 中心坐标的加权平均，如果一方丢失， 就赋值为另外一个， 都没有就赋值为原来的值 is_left_angle :代表是否有直角，！！！信息丢失 其实，可以用一个字符来表示，是左转还是右转 T(T字形) L(Left) R(Right) last_x, last_y 是两个直线的交叉点的坐标 改写为 intersect_x，intersect_y args = [ get_symbol(yaw_angle), # 偏航角符号 abs(int(yaw_angle)), # 偏航角 get_symbol(sum_x), # 光流数据sux_x的符号 abs(int(sum_x)), # 光流数据sum_x get_symbol(sum_y), # 光流数据sum_y的符号 abs(int(sum_y)), # 光流数据 sum_y int(cx_mean), # x的中心，三个取样区域色块中心x坐标的平均值 int(cx), int(cy), int(is_left_angle), int(last_x), int(last_y) ] # 将数值列表按照通信协议，转换为待发送的字符 info = &#x27;s%c%.2d%c%.2d%c%.2d%.2d%.2d%.2d%.2d%.2d%.2d#&#x27;%tuple(args) global is_debug if is_debug: print(&#x27;s%c%.2d%c%.2d%c%.2d | cx_mean=%.2d cx=%.2d cy=%.2d Turn Left: %.2d | %.2d%.2d#&#x27;%tuple(args)) &#x27;&#x27;&#x27; if cx_mean &gt;= 22 and cx_mean &lt;=40 : info=&#x27;G&#x27; if cx_mean&lt;22 : info=&#x27;L&#x27; if cx_mean&gt;40 : info=&#x27;R&#x27; if is_t : info=&#x27;S&#x27; ternleft() return info#--------------串口UART部分 END -------------------#--------------定时器部分 START -------------------is_need_send_data = False # 是否需要发送数据的信号标志def uart_time_trigger(timer): &#x27;&#x27;&#x27; 串口发送数据的定时器，定时器的回调函数 &#x27;&#x27;&#x27; global is_need_send_data is_need_send_data = True# 初始化定时器 频率为20HZ 每秒执行20次tim = Timer(4, freq=20)# 设定定时器的回调函数tim.callback(uart_time_trigger)#--------------定时器部分 END -------------------#--------------直线与直角检测部分 START -------------------INTERSERCT_ANGLE_THRESHOLD = (45,90)# 直线灰度图颜色阈值LINE_COLOR_THRESHOLD = [(20, 80)]# 如果直线是白色的，阈值修改为：# LINE_COLOR_THRESHOLD = [(128, 255)]# 取样窗口ROIS = &#123; &#x27;down&#x27;: (0, 55, 64, 8), # 横向取样-下方 1 &#x27;middle&#x27;: (0, 28, 64, 8), # 横向取样-中间 2 &#x27;up&#x27;: (0, 0, 64, 8), # 横向取样-上方 3 &#x27;left&#x27;: (0, 0, 8, 64), # 纵向取样-左侧 4 &#x27;right&#x27;: (56, 0, 8, 64) # 纵向取样-右侧 5&#125;def find_blobs_in_rois(img): &#x27;&#x27;&#x27; 在ROIS中寻找色块，获取ROI中色块的中心区域与是否有色块的信息 &#x27;&#x27;&#x27; global ROIS global is_debug roi_blobs_result = &#123;&#125; # 在各个ROI中寻找色块的结果记录 for roi_direct in ROIS.keys(): roi_blobs_result[roi_direct] = &#123; &#x27;cx&#x27;: -1, &#x27;cy&#x27;: -1, &#x27;blob_flag&#x27;: False &#125; for roi_direct, roi in ROIS.items(): blobs=img.find_blobs(LINE_COLOR_THRESHOLD, roi=roi, merge=True, pixels_area=10) if len(blobs) == 0: continue largest_blob = max(blobs, key=lambda b: b.pixels()) x,y,width,height = largest_blob[:4] if not(width &gt;=5 and width &lt;= 15 and height &gt;= 5 and height &lt;= 15): # 根据色块的宽度进行过滤 continue roi_blobs_result[roi_direct][&#x27;cx&#x27;] = largest_blob.cx() roi_blobs_result[roi_direct][&#x27;cy&#x27;] = largest_blob.cy() roi_blobs_result[roi_direct][&#x27;blob_flag&#x27;] = True if is_debug: img.draw_rectangle((x,y,width, height), color=(255)) return roi_blobs_resultdef visualize_result(canvas, cx_mean, cx, cy, is_turn_left, is_turn_right, is_t, is_cross): &#x27;&#x27;&#x27; 可视化结果 &#x27;&#x27;&#x27; if not(is_turn_left or is_turn_right or is_t or is_cross): mid_x = int(canvas.width()/2) mid_y = int(canvas.height()/2) # 绘制x的均值点 canvas.draw_circle(int(cx_mean), mid_y, 5, color=(255)) # 绘制屏幕中心点 canvas.draw_circle(mid_x, mid_y, 8, color=(0)) canvas.draw_line((mid_x, mid_y, int(cx_mean), mid_y), color=(255)) turn_type = &#x27;N&#x27; # 啥转角也不是 if is_t or is_cross: # 十字形或者T形 canvas.draw_cross(int(cx), int(cy), size=10, color=(255)) canvas.draw_circle(int(cx), int(cy), 5, color=(255)) if is_t: turn_type = &#x27;T&#x27; # T字形状 elif is_cross: turn_type = &#x27;C&#x27; # 十字形 elif is_turn_left: turn_type = &#x27;L&#x27; # 左转 elif is_turn_right: turn_type = &#x27;R&#x27; # 右转 canvas.draw_string(0, 0, turn_type, color=(0))#--------------直线与直角检测部分 END -------------------#---------------------MAIN-----------------------last_cx = 0last_cy = 0while True: if not is_need_send_data: # 不需要发送数据 continue is_need_send_data = False # 拍摄图片 img = sensor.snapshot() # 去除图像畸变 img.lens_corr(DISTORTION_FACTOR) # 创建画布 # canvas = img.copy() # 为了IDE显示方便，直接在代码结尾 用IMG绘制 # 注意：林林的代码里 计算直线之间的交点的代码没有用到 lines = img.find_lines(threshold=1000, theta_margin = 50, rho_margin = 50) # 寻找相交的点 要求满足角度阈值 intersect_pt = GeometryFeature.find_interserct_lines(lines, angle_threshold=(45,90), window_size=(IMG_WIDTH, IMG_HEIGHT)) if intersect_pt is None: # 直线与直线之间的夹角不满足阈值范围 intersect_x = 0 intersect_y = 0 else: intersect_x, intersect_y = intersect_pt reslut = find_blobs_in_rois(img) # 判断是否需要左转与右转 is_turn_left = False is_turn_right = False if (not reslut[&#x27;up&#x27;][&#x27;blob_flag&#x27;] ) and reslut[&#x27;down&#x27;][&#x27;blob_flag&#x27;]: if reslut[&#x27;left&#x27;][&#x27;blob_flag&#x27;]: is_turn_left = True if reslut[&#x27;right&#x27;][&#x27;blob_flag&#x27;]: is_turn_right = True # 判断是否为T形的轨道 is_t = False # 判断是否十字形轨道 is_cross = False cnt = 0 for roi_direct in [&#x27;up&#x27;, &#x27;down&#x27;, &#x27;left&#x27;, &#x27;right&#x27;]: if reslut[roi_direct][&#x27;blob_flag&#x27;]: cnt += 1 is_t = cnt == 3 is_cross = cnt == 4 # cx_mean 用于确定视角中的轨道中心 # 用于表示左右偏移量 cx_mean = 0 for roi_direct in [&#x27;up&#x27;, &#x27;down&#x27;, &#x27;middle&#x27;]: if reslut[roi_direct][&#x27;blob_flag&#x27;]: cx_mean += reslut[roi_direct][&#x27;cx&#x27;] else: cx_mean += IMG_WIDTH / 2 cx_mean /= 3 # cx, cy 只有在T形区域检测出来的时候才有用， # 用于确定轨道中圆形的大致区域， 用于定点， 是计算圆心的一种近似方法 cx = 0 cy = 0 if is_cross or is_t: # 只在出现十字形或者T字形才计算圆心坐标 cnt = 0 for roi_direct in [&#x27;up&#x27;, &#x27;down&#x27;]: if reslut[roi_direct][&#x27;blob_flag&#x27;]: cnt += 1 cx += reslut[roi_direct][&#x27;cx&#x27;] if cnt == 0: cx = last_cx else: cx /= cnt cnt = 0 for roi_direct in [&#x27;left&#x27;, &#x27;right&#x27;]: if reslut[roi_direct][&#x27;blob_flag&#x27;]: cnt += 1 cy += reslut[roi_direct][&#x27;cy&#x27;] if cnt == 0: cy = last_cy else: cy /= cnt # 为了兼容之前的程序，按照之前的数据通信协议发送 # 林林的代码里没有用到的变量均设为 0， 且巡线演示历程中，只用到了左转 # 发送信息格式，可以自行改造, 例如 添加 is_turn_left info = data_format_wrapper(0, 0, 0, cx_mean, cx, cy, is_turn_left, is_t, 0) uart.write(info) print(info) last_cx = cx last_cy = cy if is_debug: visualize_result(img, cx_mean, cx, cy, is_turn_left, is_turn_right, is_t, is_cross) 2.car.py12345678910111213141516171819202122232425262728293031323334353637383940414243from pyb import Pin, Timerinverse_left=False #change it to True to inverse left wheelinverse_right=False #change it to True to inverse right wheelain1 = Pin(&#x27;P0&#x27;, Pin.OUT_PP)ain2 = Pin(&#x27;P1&#x27;, Pin.OUT_PP)bin1 = Pin(&#x27;P2&#x27;, Pin.OUT_PP)bin2 = Pin(&#x27;P3&#x27;, Pin.OUT_PP)ain1.low()ain2.low()bin1.low()bin2.low()pwma = Pin(&#x27;P7&#x27;)pwmb = Pin(&#x27;P8&#x27;)tim = Timer(4, freq=1000)ch1 = tim.channel(1, Timer.PWM, pin=pwma)ch2 = tim.channel(2, Timer.PWM, pin=pwmb)ch1.pulse_width_percent(0)ch2.pulse_width_percent(0)def run(left_speed, right_speed): if inverse_left==True: left_speed=(-left_speed) if inverse_right==True: right_speed=(-right_speed) if left_speed &lt; 0: ain1.low() ain2.high() else: ain1.high() ain2.low() ch1.pulse_width_percent(int(abs(left_speed))) if right_speed &lt; 0: bin1.low() bin2.high() else: bin1.high() bin2.low() ch2.pulse_width_percent(int(abs(right_speed))) 2.pid.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pyb import millisfrom math import pi, isnanclass PID: _kp = _ki = _kd = _integrator = _imax = 0 _last_error = _last_derivative = _last_t = 0 _RC = 1/(2 * pi * 20) def __init__(self, p=0, i=0, d=0, imax=0): self._kp = float(p) self._ki = float(i) self._kd = float(d) self._imax = abs(imax) self._last_derivative = float(&#x27;nan&#x27;) def get_pid(self, error, scaler): tnow = millis() dt = tnow - self._last_t output = 0 if self._last_t == 0 or dt &gt; 1000: dt = 0 self.reset_I() self._last_t = tnow delta_time = float(dt) / float(1000) output += error * self._kp if abs(self._kd) &gt; 0 and dt &gt; 0: if isnan(self._last_derivative): derivative = 0 self._last_derivative = 0 else: derivative = (error - self._last_error) / delta_time derivative = self._last_derivative + \\ ((delta_time / (self._RC + delta_time)) * \\ (derivative - self._last_derivative)) self._last_error = error self._last_derivative = derivative output += self._kd * derivative output *= scaler if abs(self._ki) &gt; 0 and dt &gt; 0: self._integrator += (error * self._ki) * scaler * delta_time if self._integrator &lt; -self._imax: self._integrator = -self._imax elif self._integrator &gt; self._imax: self._integrator = self._imax output += self._integrator return output def reset_I(self): self._integrator = 0 self._last_derivative = float(&#x27;nan&#x27;) arduino:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;SPI.h&gt;#include &lt;Wire.h&gt;#include &lt;Adafruit_GFX.h&gt;#include &lt;Adafruit_SSD1306.h&gt;#define OLED_RESET 4Adafruit_SSD1306 display(OLED_RESET);#if (SSD1306_LCDHEIGHT != 64)#error(&quot;Height incorrect, please fix Adafruit_SSD1306.h!&quot;);#endif#define LF1 10#define LF2 11#define RI1 6#define RI2 5#define HW1 13#define HW2 12#define RED A0#define GREEN A1#define TZOUTPUT 8int leftpwm = 255;int rightpwm = 255;int quyao = 0;char com;unsigned char continue_time = 0;void go()&#123; analogWrite(LF1, leftpwm); analogWrite(LF2, 0); analogWrite(RI1, rightpwm); analogWrite(RI2, 0);&#125;void right()&#123; analogWrite(LF1, 180); analogWrite(LF2, 0); analogWrite(RI1, 0); analogWrite(RI2, 180);&#125;void left()&#123; analogWrite(LF1, 0); analogWrite(LF2, 180); analogWrite(RI1, 180); analogWrite(RI2, 0);&#125;void back()&#123; analogWrite(LF1, 0); analogWrite(LF2, leftpwm); analogWrite(RI1, 0); analogWrite(RI2, rightpwm);&#125;void carstop()&#123; analogWrite(LF1, 0); analogWrite(LF2, 0); analogWrite(RI1, 0); analogWrite(RI2, 0);&#125;void doudong()&#123; analogWrite(LF1, 150); analogWrite(LF2, 0); analogWrite(RI1, 0); analogWrite(RI2, 150);&#125;void red()&#123; digitalWrite(RED,LOW);&#125;void green()&#123; digitalWrite(GREEN,LOW);&#125;void notlight()&#123; digitalWrite(RED,HIGH); digitalWrite(GREEN,HIGH); &#125;void palldown()&#123; analogWrite(LF1, 80); analogWrite(LF2, 0); analogWrite(RI1, 85); analogWrite(RI2, 0);&#125;void setup() &#123; // put your setup code here, to run once: Serial.begin(115200); display.begin(SSD1306_SWITCHCAPVCC, 0x3C); display.clearDisplay(); display.display(); //delay(2000); pinMode(LF1, OUTPUT); pinMode(LF2, OUTPUT); pinMode(RI1, OUTPUT); pinMode(RI2, OUTPUT); pinMode(HW1, INPUT); pinMode(HW2, INPUT); pinMode(RED, OUTPUT); pinMode(GREEN, OUTPUT); pinMode(TZOUTPUT, OUTPUT); digitalWrite(TZOUTPUT,LOW); digitalWrite(RED,HIGH); digitalWrite(GREEN,HIGH);&#125;void oledisplay()&#123; // text display tests display.clearDisplay(); display.setTextSize(1); display.setTextColor(WHITE); display.setCursor(0, 0); display.print(&quot;leftpwm:&quot;); display.println(leftpwm); display.print(&quot;rightpwm:&quot;); display.println(rightpwm); display.setTextSize(2); display.print(&quot;com:&quot;); display.println(com); display.display();&#125;void cktx()&#123; //指令接收部分 //蓝牙遥控部分 // 读取串口发送的信息: if (Serial.available() &gt; 0 ) &#123; char inChar; inChar = Serial.read(); if (com != inChar) &#123; // bt_rec_flag = 1; com = inChar; &#125; &#125; // else // 调试用 //com = &#x27;S&#x27;; switch (com) &#123; case &#x27;G&#x27;: go(); Serial.println(&quot;直行&quot;); break; case &#x27;L&#x27;: left(); Serial.println(&quot;左转&quot;); break; case &#x27;R&#x27;: right(); Serial.println(&quot;右转&quot;); break; case &#x27;B&#x27;: back(); Serial.println(&quot;后退&quot;); break; case &#x27;S&#x27;: carstop(); Serial.println(&quot;停车&quot;); break; case &#x27;1&#x27;: red(); Serial.println(&quot;RED&quot;);break; case &#x27;2&#x27;: green();Serial.println(&quot;GREEN&quot;);break; case &#x27;3&#x27;: notlight();Serial.println(&quot;熄灭&quot;);break; case &#x27;H&#x27;: palldown();Serial.println(&quot;速度减半&quot;);break; default : break; &#125; &#125;void tinzhi()&#123; if(digitalRead(HW1)==HIGH||digitalRead(HW2)==HIGH) &#123; digitalWrite(TZOUTPUT,HIGH); &#125;&#125;void loop() &#123; cktx(); tinzhi(); // Serial.println(quyao); // doudong(); //oledisplay(); //delay(10);&#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://ljweb.xyz/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[{"name":"OpenMv","slug":"OpenMv","permalink":"https://ljweb.xyz/tags/OpenMv/"},{"name":"diy","slug":"diy","permalink":"https://ljweb.xyz/tags/diy/"},{"name":"arduino","slug":"arduino","permalink":"https://ljweb.xyz/tags/arduino/"}]},{"title":"typora使用教程","slug":"typora使用教程","date":"2021-11-20T17:33:07.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/20/typora使用教程/","link":"","permalink":"https://ljweb.xyz/2021/11/20/typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考：Typora入门：全网最全教程 - Hider1214 1.Typora快捷键整合123456789101112131415Ctrl+1 一阶标题 Ctrl+B 字体加粗Ctrl+2 二阶标题 Ctrl+I 字体倾斜Ctrl+3 三阶标题 Ctrl+U 下划线Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部Ctrl+5 五阶标题 Ctrl+End 返回Typora底部Ctrl+6 六阶标题 Ctrl+T 创建表格Ctrl+L 选中某句话 Ctrl+K 创建超链接Ctrl+D 选中某个单词 Ctrl+F 搜索Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片Ctrl+Shift+M 公式块 Ctrl+Shift+Q 引用Ctrl + B 加粗注：一些实体符号需要在实体符号之前加”\\”才能够显示","categories":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/tags/%E6%95%99%E7%A8%8B/"},{"name":"typora","slug":"typora","permalink":"https://ljweb.xyz/tags/typora/"}]},{"title":"51循迹小车","slug":"51循迹小车","date":"2021-11-20T16:54:55.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/20/51循迹小车/","link":"","permalink":"https://ljweb.xyz/2021/11/20/51%E5%BE%AA%E8%BF%B9%E5%B0%8F%E8%BD%A6/","excerpt":"","text":"参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;reg52.h&gt;sbit LED1=P2^7;//大灯 0亮sbit LED2=P2^2;sbit LF1=P0^2;//左前电机sbit LF2=P0^3;sbit RF1=P0^4;//右前电机sbit RF2=P0^5;sbit LB2=P0^0;//左后电机sbit LB1=P0^1;sbit RB1=P0^6;//右后电机sbit RB2=P0^7;sbit XJ1 = P2^4;//右边红外传感器的数据口sbit XJ2 = P2^5;//左边红外传感器的数据口sbit BZ1=P2^3;//左右避障传感器数据口sbit BZ2=P2^6;unsigned char zkb1 = 0;//定义了一下左边两个轮的占空比unsigned char zkb2 = 0;//定义了一下右边两个轮的占空比int t = 0;void delayms(unsigned int ms)&#123; unsigned char i=100,j; for(;ms;ms--) &#123; while(--i) &#123; j=10; while(--j); &#125; &#125;&#125;void PIT_Init()&#123; EA = 1; TMOD |= 0x01; TH0 = (65536 - 200) / 256; TL0 = (65536 - 200) % 256; ET0 = 1; TR0 = 1;&#125;void timer()interrupt 1&#123; TH0 = (65536-200)/256; TL0 = (65536-200)%256; if(t&lt;zkb1) &#123; LF1=0; LF2=1; LB1=0; LB2=1; &#125; else &#123; LF1=0; LF2=0; LB1=0; LB2=0; &#125; if(t&lt;zkb2) &#123; RF1=0; RF2=1; RB1=0; RB2=1; &#125; else &#123; RF1=0; RF2=0; RB1=0; RB2=0; &#125; t = (t + 1) %50;&#125;void run() //跑直线&#123; zkb1=7; zkb2=7;&#125;void right()&#123; zkb1=12; zkb2=0; &#125;void left()&#123; zkb1=0; zkb2=12;&#125;void stop()&#123; zkb1=0; zkb2=0;&#125;void delay(unsigned int k)&#123; unsigned int x,y; for(x=0;x&lt;k;x++) &#123; for(y=0;y&lt;200;y++); &#125;&#125;void xunji()&#123; unsigned char flag; if((XJ1==1)&amp;&amp;(XJ2==0)) &#123; flag = 0;//左边检测到黑线 &#125; else if((XJ1==0)&amp;&amp;(XJ2==1)) &#123; flag = 1;//右边检测到黑线 &#125; else if((XJ1==1)&amp;&amp;(XJ2==1)) &#123; flag = 3; &#125; else &#123; flag = 4; &#125; if((BZ1==0)||(BZ2==0)) &#123; flag = 5; &#125; switch(flag) &#123; case 0: right();delay(5);stop();LED1=1;LED2=0;delay(5);break; case 1: left();delay(5);stop(); LED1=0;LED2=1;delay(5);break; case 3: run();delay(1);stop(); LED1=1;LED2=1; delay(1);break; case 4: run();delay(1);stop(); LED1=1;LED2=1; delay(1);break; case 5: stop();delay(5);break; default: run();delay(5);stop(); LED1=1;LED2=1; delay(11);break; &#125;&#125;void main()&#123; PIT_Init(); LED1=0; LED2=0; while(1) &#123; xunji(); &#125; &#125;","categories":[{"name":"51单片机","slug":"51单片机","permalink":"https://ljweb.xyz/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"diy","slug":"diy","permalink":"https://ljweb.xyz/tags/diy/"},{"name":"51","slug":"51","permalink":"https://ljweb.xyz/tags/51/"}]},{"title":"11.9安科星轨","slug":"拍过的一些星轨","date":"2021-11-19T14:58:26.000Z","updated":"2022-02-16T14:10:43.424Z","comments":true,"path":"2021/11/19/拍过的一些星轨/","link":"","permalink":"https://ljweb.xyz/2021/11/19/%E6%8B%8D%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E6%98%9F%E8%BD%A8/","excerpt":"","text":"拍摄日期：2021年11月9日 设备：NIKON Z6 参数：15s f/5.6 24mm ISO1000","categories":[],"tags":[{"name":"星轨","slug":"星轨","permalink":"https://ljweb.xyz/tags/%E6%98%9F%E8%BD%A8/"}]},{"title":"Hello World!","slug":"HELLO","date":"2021-11-18T19:17:15.000Z","updated":"2022-02-16T14:10:43.384Z","comments":true,"path":"2021/11/18/HELLO/","link":"","permalink":"https://ljweb.xyz/2021/11/18/HELLO/","excerpt":"","text":"各种语言的Hello World1.C语言 123456#include &lt;stdio.h&gt;void mian()&#123; printf(&quot;Hello World!&quot;);&#125; 2.python 1print(&quot;Hello World!&quot;)","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ljweb.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机","slug":"51单片机","permalink":"https://ljweb.xyz/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"搬运","slug":"搬运","permalink":"https://ljweb.xyz/categories/%E6%90%AC%E8%BF%90/"},{"name":"智能车","slug":"智能车","permalink":"https://ljweb.xyz/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"},{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/categories/%E6%95%99%E7%A8%8B/"},{"name":"arduino","slug":"arduino","permalink":"https://ljweb.xyz/categories/arduino/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"https://ljweb.xyz/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"OpenMv","slug":"OpenMv","permalink":"https://ljweb.xyz/tags/OpenMv/"},{"name":"51","slug":"51","permalink":"https://ljweb.xyz/tags/51/"},{"name":"实验","slug":"实验","permalink":"https://ljweb.xyz/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"diy","slug":"diy","permalink":"https://ljweb.xyz/tags/diy/"},{"name":"电路","slug":"电路","permalink":"https://ljweb.xyz/tags/%E7%94%B5%E8%B7%AF/"},{"name":"教程","slug":"教程","permalink":"https://ljweb.xyz/tags/%E6%95%99%E7%A8%8B/"},{"name":"git","slug":"git","permalink":"https://ljweb.xyz/tags/git/"},{"name":"typora","slug":"typora","permalink":"https://ljweb.xyz/tags/typora/"},{"name":"arduino","slug":"arduino","permalink":"https://ljweb.xyz/tags/arduino/"},{"name":"C语言","slug":"C语言","permalink":"https://ljweb.xyz/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"星轨","slug":"星轨","permalink":"https://ljweb.xyz/tags/%E6%98%9F%E8%BD%A8/"}]}